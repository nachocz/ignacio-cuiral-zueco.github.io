<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Primary Meta Tags -->
    <title>2-Robot Cable Manipulation Demo | Ignacio Cuiral-Zueco</title>
    <meta name="title" content="2-Robot Cable Manipulation Demo | Ignacio Cuiral-Zueco">
    <meta name="description" content="Interactive demo of cooperative cable manipulation by two robots. Part of research on deformable object control by Ignacio Cuiral-Zueco.">
    <meta name="author" content="Ignacio Cuiral-Zueco">
    <meta name="keywords" content="robotics demo, cable manipulation, robot coordination, deformable objects, interactive demo">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://nachocz.github.io/robotics-demo.html">
    <meta property="og:title" content="2-Robot Cable Manipulation Demo | Ignacio Cuiral-Zueco">
    <meta property="og:description" content="Interactive demo of cooperative cable manipulation by two robots. Part of research on deformable object control by Ignacio Cuiral-Zueco.">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary">
    <meta property="twitter:url" content="https://nachocz.github.io/robotics-demo.html">
    <meta property="twitter:title" content="2-Robot Cable Manipulation Demo | Ignacio Cuiral-Zueco">
    <meta property="twitter:description" content="Interactive demo of cooperative cable manipulation by two robots. Part of research on deformable object control by Ignacio Cuiral-Zueco.">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://nachocz.github.io/robotics-demo.html">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 950px;
            margin-bottom: 20px;
        }

        .lang-btn {
            padding: 6px 12px;
            background: #ecf0f1;
            border: 1px solid #dfe6e9;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }

        .lang-btn:hover {
            background: #dfe6e9;
        }

        .lang-btn.active {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }

        body.dark-theme .lang-btn {
            background: #1f2633;
            border-color: #2a3140;
            color: #e6e6e6;
        }

        body.dark-theme .lang-btn:hover {
            background: #2a3140;
        }

        body.dark-theme .lang-btn.active {
            background: #2c6fb3;
            border-color: #3b82c4;
            color: #ffffff;
        }

        .demo-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 20px;
            max-width: 950px;
            width: 100%;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.8em;
        }

        canvas {
            display: block;
            background: white;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            cursor: crosshair;
        }

        #roboticsCanvas {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            margin-bottom: 0;
        }

        #errorPlot {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            border: 1px solid #ecf0f1;
            border-radius: 4px;
            background: white;
        }

        .controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .instructions {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .control-card {
            background: white;
            padding: 10px;
            border-radius: 6px;
        }

        .control-section {
            margin-bottom: 15px;
        }

        .control-section h3 {
            color: #34495e;
            font-size: 0.95em;
            margin-bottom: 8px;
        }

        .keyboard-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            font-size: 0.9em;
            color: #555;
            line-height: 1.5;
        }

        .robot-group {
            background: white;
            padding: 10px;
            border-radius: 6px;
            border-left: 4px solid #2c3e50;
        }

        .robot-group.robot2 {
            border-left-color: #8b4513;
        }

        .robot-group strong {
            display: block;
            margin-bottom: 5px;
            color: #2c3e50;
        }

        .robot-group.robot2 strong {
            color: #8b4513;
        }

        .status {
            background: #ecf0f1;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-family: 'Courier New', monospace;
            color: #2c3e50;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 20px;
            margin-top: 15px;
            align-items: start;
        }

        .plot-wrapper {
            display: flex;
            flex-direction: column;
        }

        .plot-label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-bottom: 8px;
            font-weight: 500;
        }

        #errorPlot {
            border: 1px solid #ecf0f1;
            border-radius: 4px;
            background: white;
        }

        .robot-wrapper {
            display: flex;
            flex-direction: column;
        }

        body.dark-theme {
            background: #0f1115;
            color: #e6e6e6;
        }

        body.dark-theme .demo-container,
        body.dark-theme .controls,
        body.dark-theme .status,
        body.dark-theme .instructions,
        body.dark-theme .control-card {
            background: #151922 !important;
            color: #e6e6e6 !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
        }

        body.dark-theme canvas {
            border-color: #2a3140;
        }

        body.dark-theme h1,
        body.dark-theme h3,
        body.dark-theme h4,
        body.dark-theme p,
        body.dark-theme li,
        body.dark-theme span,
        body.dark-theme label,
        body.dark-theme strong {
            color: #e6e6e6 !important;
        }

        body.dark-theme button {
            background: #2c6fb3;
        }

        body.dark-theme button:hover {
            background: #3b82c4;
        }

        body.dark-theme .plot-label {
            color: #a7b3c2;
        }

        body.dark-theme .demo-tab-btn {
            background: #1f2633;
            border-color: #2a3140;
            color: #e6e6e6;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .demo-container {
                padding: 15px;
            }

            h1 {
                font-size: 1.4em;
            }

            .visualization-container {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .plot-wrapper,
            .robot-wrapper {
                width: 100%;
            }

            .plot-label {
                font-size: 0.75em;
                margin-bottom: 6px;
            }

            #roboticsCanvas {
                width: 100% !important;
                height: auto !important;
            }

            #errorPlot {
                width: 100% !important;
                height: auto !important;
            }

            .instructions {
                font-size: 0.85em;
                padding: 10px;
            }

            .instructions ul {
                padding-left: 12px;
                line-height: 1.6;
            }

            .instructions li {
                font-size: 0.85em;
            }

            .keyboard-info {
                grid-template-columns: 1fr;
                gap: 6px;
            }

            .control-section h3 {
                font-size: 0.85em;
            }

            .control-card {
                padding: 8px;
            }

            .control-card h4 {
                font-size: 0.8em;
            }

            .control-card label {
                font-size: 0.75em;
            }

            button {
                padding: 6px 12px;
                font-size: 0.8em;
            }

            .status {
                font-size: 0.8em;
                padding: 8px;
            }
        }

    </style>
</head>
<body class="dark-theme">
    <div class="header-bar">
        <div></div>
        <div id="language-switcher" style="display: flex; gap: 6px;">
            <button id="lang-en" class="lang-btn active" data-lang="en">EN</button>
            <button id="lang-es" class="lang-btn" data-lang="es">ES</button>
        </div>
    </div>
    <div class="demo-container">
        <h1 data-i18n="title">Robot Cable Manipulation</h1>
        
        <p style="text-align: center; margin: 15px auto 20px; max-width: 700px; font-size: 0.95em; color: #555; line-height: 1.6;">
            <span data-i18n="controllerTitle">Use sliders to move robots and manipulate blue cable towards green target shape</span>
        </p>
        
        <div class="visualization-container">
            <div class="plot-wrapper">
                <p class="plot-label" data-i18n="errorPlotLabel">Cable alignment error (shape error) over time</p>
                <canvas id="errorPlot" width="300" height="250"></canvas>
            </div>
            <div class="robot-wrapper">
                <canvas id="roboticsCanvas" width="600" height="450"></canvas>
            </div>
        </div>
        
        <div class="instructions">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 12px;">
                <div>
                    <h4 style="margin: 0 0 8px 0; font-size: 0.9em;" data-i18n="leftRobot">Left Robot (Blue)</h4>
                    <div class="control-card">
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; font-size: 0.85em; margin-bottom: 4px;" data-i18n="joint1">Joint 1</label>
                            <input type="range" id="theta1Slider" min="-2" max="0.5" step="0.05" value="-1.6" style="width: 100%;">
                            <span id="theta1Value" style="font-size: 0.8em; color: #7f8c8d;">-1.60</span>
                        </div>
                        <div>
                            <label style="display: block; font-size: 0.85em; margin-bottom: 4px;" data-i18n="joint2">Joint 2</label>
                            <input type="range" id="theta2Slider" min="-2" max="2" step="0.05" value="1" style="width: 100%;">
                            <span id="theta2Value" style="font-size: 0.8em; color: #7f8c8d;">1.00</span>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h4 style="margin: 0 0 8px 0; font-size: 0.9em;" data-i18n="rightRobot">Right Robot (Brown)</h4>
                    <div class="control-card">
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; font-size: 0.85em; margin-bottom: 4px;" data-i18n="joint1">Joint 1</label>
                            <input type="range" id="theta3Slider" min="-2.5" max="4.5" step="0.05" value="4.1" style="width: 100%;">
                            <span id="theta3Value" style="font-size: 0.8em; color: #7f8c8d;">4.10</span>
                        </div>
                        <div>
                            <label style="display: block; font-size: 0.85em; margin-bottom: 4px;" data-i18n="joint2">Joint 2</label>
                            <input type="range" id="theta4Slider" min="-2" max="2" step="0.05" value="-0.7" style="width: 100%;">
                            <span id="theta4Value" style="font-size: 0.8em; color: #7f8c8d;">-0.70</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="text-align: center; margin-bottom: 12px;">
                <div style="margin-bottom: 10px;">
                    <span data-i18n="cableAlignmentError">Current cable alignment error:</span> <span id="errorDisplay" style="font-weight: 600; color: #3498db;">0.00</span>
                </div>
                <button id="newTargetBtn" style="padding: 10px 24px; font-weight: 600; font-size: 0.95em;" data-i18n="newTargetBtn">New Target Shape</button>
            </div>
            
            <p style="margin: 0 0 12px 0; font-weight: 600;" data-i18n="howToPlay">How to Play</p>
            <ul style="margin: 0 0 12px 0; padding-left: 20px; line-height: 1.8;">
                <li><strong data-i18n="goal">Goal:</strong> <span data-i18n="goalDesc">Adjust the robot joints to shape the cable and match the target shape shown as a green dashed line</span></li>
                <li><strong data-i18n="controls">Controls:</strong> <span data-i18n="controlsDesc">Use the sliders to change joint angles for each robot. The blue robot on the left and brown robot on the right work together to control the cable</span></li>
                <li><strong data-i18n="feedback">Feedback:</strong> <span data-i18n="feedbackDesc">The error curve shows how close you are to the target. Lower values are better. Try "New Target Shape" for different challenges</span></li>
            </ul>
            
            <p style="margin: 0 0 12px 0; font-weight: 600;" data-i18n="whyMatters">Why This Matters</p>
            <ul style="margin: 0 0 12px 20px; padding-left: 20px; line-height: 1.8;">
                <li data-i18n="matterText1">Manipulating soft objects like cables and ropes is a key challenge in robotics. These materials show up constantly in real tasks</li>
                <li><strong data-i18n="note">Note:</strong> <span data-i18n="matterText2">Not all target shapes can be achieved with this cable and robot setup. Determining whether a shape is reachable for a given object and manipulation method is still an open research question</span></li>
            </ul>
        </div>
        
        <div class="controls" style="margin-top: 15px;">
            <div class="control-section">
            </div>
        </div>
    </div>

    <script>
        // i18n Translations Object
        const translations = {
            en: {
                title: 'Robot Cable Manipulation',
                controllerTitle: 'Use sliders to move robots and manipulate blue cable towards green target shape',
                howToPlay: 'How to Play',
                goal: 'Objective:',
                goalDesc: 'Adjust the robot joints so that the cable acquires the target shape (dashed green line)',
                controls: 'Controls:',
                controlsDesc: 'Use the sliders to change the angles of each joint. The blue robot (left) and brown robot (right) control the cable together',
                feedback: 'Feedback:',
                feedbackDesc: 'The error graph indicates how close you are to the target (the lower, the better). Use the "New Target Shape" button to get a new target shape',
                whyMatters: 'Why does this matter?',
                matterText1: 'Manipulating soft objects (cables, ropes, fabrics) is a big challenge in robotics. These materials frequently appear in real-world applications such as domestic manipulation (clothes, food), agriculture (plants, fruits), manufacturing (fabrics, foams), and more.',
                note: 'Note:',
                matterText2: 'Not all target shapes are achievable with this setup: material limits, robot movement constraints, grasping points... all condition the possible achievable shapes. Determining which shapes can be achieved with a given object and manipulation capabilities is still an open research problem',
                leftRobot: 'Left Robot (Blue)',
                rightRobot: 'Right Robot (Brown)',
                joint1: 'Joint 1',
                joint2: 'Joint 2',
                newTargetBtn: 'New Target Shape',
                errorPlotLabel: 'Cable alignment error (shape error) over time',
                cableAlignmentError: 'Current cable alignment error:',
                legendTargetShape: 'Target shape',
                legendCurrentShape: 'Current shape'
            },
            es: {
                title: 'Manipulación Robótica de un Cable',
                controllerTitle: 'Usa los deslizadores para mover los robots y manipular el cable azul hacia la forma objetivo verde',
                howToPlay: 'Cómo Jugar',
                goal: 'Objetivo:',
                goalDesc: 'Ajusta las articulaciones de los robots para que el cable adopte la forma objetivo (línea verde discontinua)',
                controls: 'Controles:',
                controlsDesc: 'Usa los deslizadores para cambiar los ángulos de cada articulación. El robot azul (izquierda) y el marrón (derecha) controlan el cable conjuntamente',
                feedback: 'Retroalimentación:',
                feedbackDesc: 'La gráfica de error indica cómo de cerca estás del objetivo (cuanto más bajo, mejor). Usa el botón "Nueva Forma Objetivo" para obtener una nueva forma objetivo',
                whyMatters: '¿Por qué es esto importante?',
                matterText1: 'Manipular objetos blandos (cables, cuerdas, tejidos) es un reto clave en robótica. Estos materiales aparecen constantemente en aplicaciones reales como manipulación doméstica (ropa, comida), agricultura (plantas, frutas), fabricación (telas, espumas), etc.',
                note: 'Nota:',
                matterText2: 'No todas las formas objetivo son alcanzables dado un objeto y una configuración para su manipulación: los límites del material, del movimiento de los robots, los puntos de agarre... todo condiciona las posibles formas alcanzables. Determinar y caracterizar qué formas se pueden conseguir con un objeto y unas capacidades de actuación dadas sigue siendo un problema abierto de investigación',
                leftRobot: 'Robot Izquierdo (Azul)',
                rightRobot: 'Robot Derecho (Marrón)',
                joint1: 'Articulación 1',
                joint2: 'Articulación 2',
                newTargetBtn: 'Nueva Forma Objetivo',
                errorPlotLabel: 'Error de alineación del cable (error de forma) a lo largo del tiempo',
                cableAlignmentError: 'Error actual de alineación del cable:',
                legendTargetShape: 'Forma objetivo',
                legendCurrentShape: 'Forma actual'
            }
        };

        // i18n Functions
        let currentLanguage = localStorage.getItem('language') || 'en';

        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('language', lang);
            applyTranslations();
            updateLanguageButtons();
        }

        function applyTranslations() {
            const t = translations[currentLanguage];
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (t[key]) {
                    element.textContent = t[key];
                }
            });
            document.documentElement.lang = currentLanguage;
        }

        function updateLanguageButtons() {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-lang') === currentLanguage);
            });
        }

        // Initialize i18n on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Check if parent page has set a language preference
            const parentLang = window.parent.document ? window.parent.document.documentElement.lang : null;
            if (parentLang && (parentLang === 'en' || parentLang === 'es')) {
                currentLanguage = parentLang;
                localStorage.setItem('language', parentLang);
            }
            
            applyTranslations();
            updateLanguageButtons();

            // Attach language button listeners
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    setLanguage(btn.getAttribute('data-lang'));
                });
            });
            
            // Apply dark theme if parent page has it
            if (window.parent.document.body.classList.contains('dark-theme')) {
                document.body.classList.add('dark-theme');
            }
        });

        // Listen for language changes from parent window
        window.addEventListener('message', (event) => {
            if (event.data.type === 'setLanguage') {
                setLanguage(event.data.language);
            }
        });

        // Polyfill for rounded rectangles (for older browsers)
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
            };
        }
        
        const config = {
            numPoints: 15,  // Shorter cable
            constraintIterations: 10,  // Lower iterations for softer cable
            robotSpeed: 3.5,
            segmentLength: 20,  // Longer segments for fewer points
            smoothingStrength: 0.05,  // Very low smoothing - soft and flexible
            link1Length: 90,  // Larger links
            link2Length: 90,  // Larger links
            damping: 0.85,  // Less aggressive damping
            gravity: 0.02   // Minimal gravity
        };

        // DOM elements
        const canvas = document.getElementById('roboticsCanvas');
        const ctx = canvas.getContext('2d');
        const errorPlot = document.getElementById('errorPlot');
        const errorPlotCtx = errorPlot.getContext('2d');
        const errorDisplay = document.getElementById('errorDisplay');
        const newTargetBtn = document.getElementById('newTargetBtn');
        
        // Error history for plotting
        let errorHistory = [];
        const maxHistoryLength = 2000;  // Keep last 2000 frames (~33 seconds at 60fps)

        // State
        let cable = [];
        let cableVel = [];  // Velocity for each cable point
        let target = [];
        let targetCable = [];  // The actual target cable shape
        
        // Left robot
        let robotPos = [450, 200];
        let robotBase = [150, 250];  // Robot base position (adjusted for 600px canvas)
        let theta1 = -1.6;  // First link angle
        let theta2 = 1;  // Second link angle
        
        // Right robot
        let robot2Pos = [450, 200];
        let robot2Base = [450, 250];  // Right robot base position (adjusted for 600px canvas)
        let theta3 = 4.1;  // First link angle (pointing left)
        let theta4 = -0.7;  // Second link angle
        
        // Ghost robots (for target generation)
        let theta1_ghost = -1.6;
        let theta2_ghost = 1;
        let theta3_ghost = 4.1;
        let theta4_ghost = -0.7;
        
        let targetRobotPos = [400, 150];  // Virtual target robot position
        let keys = {};
        let rmsError = 0;

        // Initialize cable as straight line between two robots
        function initCable() {
            cable = [];
            cableVel = [];
            const ee1 = getEndEffector();
            const ee2 = getEndEffector2();
            for (let i = 0; i < config.numPoints; i++) {
                const t = i / (config.numPoints - 1);
                cable.push([
                    ee1.j2[0] + t * (ee2.j2[0] - ee1.j2[0]),
                    ee1.j2[1] + t * (ee2.j2[1] - ee1.j2[1])
                ]);
                cableVel.push([0, 0]);
            }
        }

        // Simple 2-link inverse kinematics for left robot
        function solveIK(targetX, targetY) {
            const L1 = config.link1Length;
            const L2 = config.link2Length;
            const bx = robotBase[0];
            const by = robotBase[1];
            
            const dx = targetX - bx;
            const dy = targetY - by;
            const d = Math.sqrt(dx * dx + dy * dy);
            
            // Clamp distance to reachable range
            const maxDist = L1 + L2;
            const minDist = Math.abs(L1 - L2);
            
            if (d > maxDist) {
                theta1 = Math.atan2(dy, dx);
                theta2 = 0;
                return;
            }
            
            if (d < minDist) {
                theta1 = Math.atan2(dy, dx);
                theta2 = Math.PI;
                return;
            }
            
            const cosTheta2 = (d * d - L1 * L1 - L2 * L2) / (2 * L1 * L2);
            const sinTheta2 = Math.sqrt(Math.max(0, 1 - cosTheta2 * cosTheta2));
            theta2 = Math.atan2(sinTheta2, cosTheta2);
            
            const alpha = Math.atan2(dy, dx);
            const beta = Math.atan2(L2 * sinTheta2, L1 + L2 * cosTheta2);
            theta1 = alpha - beta;
        }
        
        // Inverse kinematics for right robot
        function solveIK2(targetX, targetY) {
            const L1 = config.link1Length;
            const L2 = config.link2Length;
            const bx = robot2Base[0];
            const by = robot2Base[1];
            
            const dx = targetX - bx;
            const dy = targetY - by;
            const d = Math.sqrt(dx * dx + dy * dy);
            
            const maxDist = L1 + L2;
            const minDist = Math.abs(L1 - L2);
            
            if (d > maxDist) {
                theta3 = Math.atan2(dy, dx);
                theta4 = 0;
                return;
            }
            
            if (d < minDist) {
                theta3 = Math.atan2(dy, dx);
                theta4 = Math.PI;
                return;
            }
            
            const cosTheta4 = (d * d - L1 * L1 - L2 * L2) / (2 * L1 * L2);
            const sinTheta4 = Math.sqrt(Math.max(0, 1 - cosTheta4 * cosTheta4));
            theta4 = Math.atan2(sinTheta4, cosTheta4);
            
            const alpha = Math.atan2(dy, dx);
            const beta = Math.atan2(L2 * sinTheta4, L1 + L2 * cosTheta4);
            theta3 = alpha - beta;
        }

        // Get end effector position from joint angles
        function getEndEffector() {
            const bx = robotBase[0];
            const by = robotBase[1];
            const L1 = config.link1Length;
            const L2 = config.link2Length;
            
            const joint1X = bx + L1 * Math.cos(theta1);
            const joint1Y = by + L1 * Math.sin(theta1);
            
            const joint2X = joint1X + L2 * Math.cos(theta1 + theta2);
            const joint2Y = joint1Y + L2 * Math.sin(theta1 + theta2);
            
            return {
                j0: [bx, by],
                j1: [joint1X, joint1Y],
                j2: [joint2X, joint2Y]
            };
        }
        
        // Get end effector position for right robot
        function getEndEffector2() {
            const bx = robot2Base[0];
            const by = robot2Base[1];
            const L1 = config.link1Length;
            const L2 = config.link2Length;
            
            const joint1X = bx + L1 * Math.cos(theta3);
            const joint1Y = by + L1 * Math.sin(theta3);
            
            const joint2X = joint1X + L2 * Math.cos(theta3 + theta4);
            const joint2Y = joint1Y + L2 * Math.sin(theta3 + theta4);
            
            return {
                j0: [bx, by],
                j1: [joint1X, joint1Y],
                j2: [joint2X, joint2Y]
            };
        }
        
        // Get ghost end effectors (for target generation)
        function getGhostEndEffector1() {
            const bx = robotBase[0];
            const by = robotBase[1];
            const L1 = config.link1Length;
            const L2 = config.link2Length;
            
            const joint1X = bx + L1 * Math.cos(theta1_ghost);
            const joint1Y = by + L1 * Math.sin(theta1_ghost);
            
            const joint2X = joint1X + L2 * Math.cos(theta1_ghost + theta2_ghost);
            const joint2Y = joint1Y + L2 * Math.sin(theta1_ghost + theta2_ghost);
            
            return [joint2X, joint2Y];
        }
        
        function getGhostEndEffector2() {
            const bx = robot2Base[0];
            const by = robot2Base[1];
            const L1 = config.link1Length;
            const L2 = config.link2Length;
            
            const joint1X = bx + L1 * Math.cos(theta3_ghost);
            const joint1Y = by + L1 * Math.sin(theta3_ghost);
            
            const joint2X = joint1X + L2 * Math.cos(theta3_ghost + theta4_ghost);
            const joint2Y = joint1Y + L2 * Math.sin(theta3_ghost + theta4_ghost);
            
            return [joint2X, joint2Y];
        }

        // Generate random target shape using ghost robot poses
        function generateTarget() {
            // Set ghost robots to random poses constrained to workspace quadrants
            // Left robot: first quadrant (top-right) - angles from -π/2 to 0
            theta1_ghost = -Math.random() * Math.PI / 2;
            theta2_ghost = -Math.PI / 2 + Math.random() * Math.PI;
            
            // Right robot: second quadrant (top-left) - angles from π to 3π/2
            theta3_ghost = Math.PI + Math.random() * Math.PI / 2;
            theta4_ghost = -Math.PI / 2 + Math.random() * Math.PI;
            
            // Get ghost end effector positions
            const ghostEe1 = getGhostEndEffector1();
            const ghostEe2 = getGhostEndEffector2();
            
            // Initialize target cable as straight line between ghost end effectors
            targetCable = [];
            for (let i = 0; i < config.numPoints; i++) {
                const t = i / (config.numPoints - 1);
                targetCable.push([
                    ghostEe1[0] + t * (ghostEe2[0] - ghostEe1[0]),
                    ghostEe1[1] + t * (ghostEe2[1] - ghostEe1[1])
                ]);
            }
            
            // Solve target cable constraints to get a realistic shape
            solveTargetCable();
            
            // Copy to target display
            target = targetCable.map(p => [...p]);
        }
        
        // Solve target cable constraints (same as main cable)
        function solveTargetCable() {
            for (let iter = 0; iter < config.constraintIterations; iter++) {
                // Segment length constraints
                for (let i = 1; i < targetCable.length; i++) {
                    const p0 = targetCable[i - 1];
                    const p1 = targetCable[i];
                    const dx = p1[0] - p0[0];
                    const dy = p1[1] - p0[1];
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 0.01) continue;
                    
                    const correction = (config.segmentLength - dist) / dist * 0.5;
                    const cdx = dx * correction;
                    const cdy = dy * correction;
                    
                    if (i > 1) {
                        p0[0] -= cdx;
                        p0[1] -= cdy;
                    }
                    p1[0] += cdx;
                    p1[1] += cdy;
                }
                
                // Smoothing via bending constraints
                for (let i = 1; i < targetCable.length - 1; i++) {
                    const p0 = targetCable[i - 1];
                    const p1 = targetCable[i];
                    const p2 = targetCable[i + 1];
                    
                    const mx = (p0[0] + p2[0]) / 2;
                    const my = (p0[1] + p2[1]) / 2;
                    
                    p1[0] += (mx - p1[0]) * config.smoothingStrength;
                    p1[1] += (my - p1[1]) * config.smoothingStrength;
                }
            }
            
            // Enforce constraints to ghost end effectors
            const ghostEe1 = getGhostEndEffector1();
            const ghostEe2 = getGhostEndEffector2();
            targetCable[0] = [...ghostEe1];
            targetCable[targetCable.length - 1] = [...ghostEe2];
        }

        // Cubic Hermite spline based cable - rich curves from position and orientation constraints
        function solveCable() {
            const ee1 = getEndEffector();
            const ee2 = getEndEffector2();
            
            // Endpoint positions
            const P0 = ee1.j2;
            const P1 = ee2.j2;
            
            // Endpoint tangent directions from robot orientations
            const angle1 = theta1 + theta2;
            const angle2 = theta3 + theta4;
            
            // Tangent vectors - magnitude controls curvature strength
            const tangentScale = 70;  // How much the orientation influences curve shape
            const T0 = [
                Math.cos(angle1) * tangentScale,
                Math.sin(angle1) * tangentScale
            ];
            const T1 = [
                Math.cos(angle2) * tangentScale,
                Math.sin(angle2) * tangentScale
            ];
            
            // Generate cable points using cubic Hermite interpolation
            cable = [];
            for (let i = 0; i < config.numPoints; i++) {
                const t = i / (config.numPoints - 1);
                
                // Hermite basis functions
                const h00 = 2 * t * t * t - 3 * t * t + 1;
                const h10 = t * t * t - 2 * t * t + t;
                const h01 = -2 * t * t * t + 3 * t * t;
                const h11 = t * t * t - t * t;
                
                // Hermite interpolation: P(t) = h00*P0 + h10*T0 + h01*P1 + h11*T1
                const x = h00 * P0[0] + h10 * T0[0] + h01 * P1[0] + h11 * T1[0];
                const y = h00 * P0[1] + h10 * T0[1] + h01 * P1[1] + h11 * T1[1];
                
                cable.push([x, y]);
            }
        }

        // Calculate RMS error as averaged point-to-point error
        function computeRmsError() {
            if (target.length === 0) return 0;
            let sumError = 0;
            for (let i = 0; i < cable.length; i++) {
                const dx = cable[i][0] - target[i][0];
                const dy = cable[i][1] - target[i][1];
                const dist = Math.sqrt(dx * dx + dy * dy);
                sumError += dist;
            }
            return sumError / cable.length;  // Average point-to-point error
        }

        // Render main robotics demo
        function render() {
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw target cable (bright green - clearly visible)
            if (target.length > 0) {
                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.setLineDash([10, 8]);  // Dashed line with more spacing
                ctx.beginPath();
                ctx.moveTo(target[0][0], target[0][1]);
                for (let i = 1; i < target.length; i++) {
                    ctx.lineTo(target[i][0], target[i][1]);
                }
                ctx.stroke();
                ctx.setLineDash([]);  // Reset line dash
            }
            
            // Draw actual cable (bold blue)
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 8;  // Larger cable
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(cable[0][0], cable[0][1]);
            for (let i = 1; i < cable.length; i++) {
                ctx.lineTo(cable[i][0], cable[i][1]);
            }
            ctx.stroke();
            
            // Draw cable points (small dots - less visible)
            ctx.fillStyle = '#3498db';
            ctx.globalAlpha = 0.4;
            for (let i = 0; i < cable.length; i++) {
                ctx.beginPath();
                ctx.arc(cable[i][0], cable[i][1], 2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
            
            // Draw left robot arm
            const ee1 = getEndEffector();
            
            // Draw robot base with gradient
            const baseGradient1 = ctx.createLinearGradient(ee1.j0[0] - 25, ee1.j0[1] - 8, ee1.j0[0] - 25, ee1.j0[1] + 8);
            baseGradient1.addColorStop(0, '#2a2a2a');
            baseGradient1.addColorStop(0.5, '#1a1a1a');
            baseGradient1.addColorStop(1, '#0f0f0f');
            ctx.fillStyle = baseGradient1;
            ctx.fillRect(ee1.j0[0] - 25, ee1.j0[1] - 8, 50, 16);
            
            // Base outline
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.strokeRect(ee1.j0[0] - 25, ee1.j0[1] - 8, 50, 16);
            
            // Draw links with metallic gradient effect
            for (let i = 0; i < 2; i++) {
                const start = i === 0 ? ee1.j0 : ee1.j1;
                const end = i === 0 ? ee1.j1 : ee1.j2;
                
                // Shadow
                ctx.strokeStyle = 'rgba(44, 62, 80, 0.15)';
                ctx.lineWidth = 18;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(start[0] + 2, start[1] + 2);
                ctx.lineTo(end[0] + 2, end[1] + 2);
                ctx.stroke();
                
                // Gradient for metallic look
                const linkGradient = ctx.createLinearGradient(
                    start[0], start[1] - 8,
                    start[0], start[1] + 8
                );
                linkGradient.addColorStop(0, '#3d5a6b');
                linkGradient.addColorStop(0.5, '#2c3e50');
                linkGradient.addColorStop(1, '#1a252e');
                ctx.strokeStyle = linkGradient;
                ctx.lineWidth = 16;
                ctx.beginPath();
                ctx.moveTo(start[0], start[1]);
                ctx.lineTo(end[0], end[1]);
                ctx.stroke();
            }
            
            // Draw joints with radial gradient (3D effect)
            for (let j of [ee1.j0, ee1.j1]) {
                // Outer shadow
                const shadowGradient = ctx.createRadialGradient(j[0], j[1], 0, j[0], j[1], 12);
                shadowGradient.addColorStop(0, 'rgba(52, 73, 94, 0)');
                shadowGradient.addColorStop(0.8, 'rgba(52, 73, 94, 0)');
                shadowGradient.addColorStop(1, 'rgba(52, 73, 94, 0.3)');
                ctx.fillStyle = shadowGradient;
                ctx.beginPath();
                ctx.arc(j[0], j[1], 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Joint with radial gradient
                const jointGradient = ctx.createRadialGradient(j[0] - 2, j[1] - 2, 0, j[0], j[1], 10);
                jointGradient.addColorStop(0, '#4a6278');
                jointGradient.addColorStop(0.7, '#34495e');
                jointGradient.addColorStop(1, '#2c3e50');
                ctx.fillStyle = jointGradient;
                ctx.beginPath();
                ctx.arc(j[0], j[1], 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.arc(j[0] - 2, j[1] - 2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Center bolt
                ctx.fillStyle = '#1a252e';
                ctx.beginPath();
                ctx.arc(j[0], j[1], 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw parallel jaw gripper (more realistic)
            const gripperAngle = theta1 + theta2;
            const gripperWidth = 18;
            const jawLength = 12;
            const jawWidth = 4;
            
            // Gripper base (small connecting piece)
            ctx.fillStyle = '#34495e';
            ctx.beginPath();
            ctx.arc(ee1.j2[0], ee1.j2[1], 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw two parallel jaws
            for (let side of [-1, 1]) {
                const perpAngle = gripperAngle + Math.PI / 2;
                const jawBaseX = ee1.j2[0] + side * (gripperWidth / 2) * Math.cos(perpAngle);
                const jawBaseY = ee1.j2[1] + side * (gripperWidth / 2) * Math.sin(perpAngle);
                
                // Jaw with gradient
                const jawGradient = ctx.createLinearGradient(
                    jawBaseX, jawBaseY - jawWidth / 2,
                    jawBaseX, jawBaseY + jawWidth / 2
                );
                jawGradient.addColorStop(0, '#4a6278');
                jawGradient.addColorStop(0.5, '#34495e');
                jawGradient.addColorStop(1, '#2c3e50');
                
                ctx.save();
                ctx.translate(jawBaseX, jawBaseY);
                ctx.rotate(gripperAngle);
                ctx.fillStyle = jawGradient;
                ctx.fillRect(0, -jawWidth / 2, jawLength, jawWidth);
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, -jawWidth / 2, jawLength, jawWidth);
                ctx.restore();
            }
            
            // Draw right robot arm (mirror)
            const ee2 = getEndEffector2();
            
            // Draw robot base with gradient
            const baseGradient2 = ctx.createLinearGradient(ee2.j0[0] - 25, ee2.j0[1] - 8, ee2.j0[0] - 25, ee2.j0[1] + 8);
            baseGradient2.addColorStop(0, '#2a2a2a');
            baseGradient2.addColorStop(0.5, '#1a1a1a');
            baseGradient2.addColorStop(1, '#0f0f0f');
            ctx.fillStyle = baseGradient2;
            ctx.fillRect(ee2.j0[0] - 25, ee2.j0[1] - 8, 50, 16);
            
            // Base outline
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.strokeRect(ee2.j0[0] - 25, ee2.j0[1] - 8, 50, 16);
            
            // Draw links with metallic gradient effect
            for (let i = 0; i < 2; i++) {
                const start = i === 0 ? ee2.j0 : ee2.j1;
                const end = i === 0 ? ee2.j1 : ee2.j2;
                
                // Shadow
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.15)';
                ctx.lineWidth = 18;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(start[0] + 2, start[1] + 2);
                ctx.lineTo(end[0] + 2, end[1] + 2);
                ctx.stroke();
                
                // Gradient for metallic look
                const linkGradient = ctx.createLinearGradient(
                    start[0], start[1] - 8,
                    start[0], start[1] + 8
                );
                linkGradient.addColorStop(0, '#a0653a');
                linkGradient.addColorStop(0.5, '#8b4513');
                linkGradient.addColorStop(1, '#6b3410');
                ctx.strokeStyle = linkGradient;
                ctx.lineWidth = 16;
                ctx.beginPath();
                ctx.moveTo(start[0], start[1]);
                ctx.lineTo(end[0], end[1]);
                ctx.stroke();
            }
            
            // Draw joints with radial gradient (3D effect)
            for (let j of [ee2.j0, ee2.j1]) {
                // Outer shadow
                const shadowGradient = ctx.createRadialGradient(j[0], j[1], 0, j[0], j[1], 12);
                shadowGradient.addColorStop(0, 'rgba(101, 67, 33, 0)');
                shadowGradient.addColorStop(0.8, 'rgba(101, 67, 33, 0)');
                shadowGradient.addColorStop(1, 'rgba(101, 67, 33, 0.3)');
                ctx.fillStyle = shadowGradient;
                ctx.beginPath();
                ctx.arc(j[0], j[1], 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Joint with radial gradient
                const jointGradient = ctx.createRadialGradient(j[0] - 2, j[1] - 2, 0, j[0], j[1], 10);
                jointGradient.addColorStop(0, '#8b6239');
                jointGradient.addColorStop(0.7, '#654321');
                jointGradient.addColorStop(1, '#4a2f18');
                ctx.fillStyle = jointGradient;
                ctx.beginPath();
                ctx.arc(j[0], j[1], 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.arc(j[0] - 2, j[1] - 2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Center bolt
                ctx.fillStyle = '#3a2410';
                ctx.beginPath();
                ctx.arc(j[0], j[1], 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw parallel jaw gripper (more realistic)
            const gripperAngle2 = theta3 + theta4;
            const gripperWidth2 = 18;
            const jawLength2 = 12;
            const jawWidth2 = 4;
            
            // Gripper base (small connecting piece)
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.arc(ee2.j2[0], ee2.j2[1], 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw two parallel jaws
            for (let side of [-1, 1]) {
                const perpAngle = gripperAngle2 + Math.PI / 2;
                const jawBaseX = ee2.j2[0] + side * (gripperWidth2 / 2) * Math.cos(perpAngle);
                const jawBaseY = ee2.j2[1] + side * (gripperWidth2 / 2) * Math.sin(perpAngle);
                
                // Jaw with gradient
                const jawGradient = ctx.createLinearGradient(
                    jawBaseX, jawBaseY - jawWidth2 / 2,
                    jawBaseX, jawBaseY + jawWidth2 / 2
                );
                jawGradient.addColorStop(0, '#8b6239');
                jawGradient.addColorStop(0.5, '#654321');
                jawGradient.addColorStop(1, '#4a2f18');
                
                ctx.save();
                ctx.translate(jawBaseX, jawBaseY);
                ctx.rotate(gripperAngle2);
                ctx.fillStyle = jawGradient;
                ctx.fillRect(0, -jawWidth2 / 2, jawLength2, jawWidth2);
                ctx.strokeStyle = '#4a2f18';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, -jawWidth2 / 2, jawLength2, jawWidth2);
                ctx.restore();
            }
            
            // Draw legend in top-left corner
            const legendX = 10;
            const legendY = 10;
            const lineLength = 30;
            const lineSpacing = 20;
            
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            
            // Green dashed line (target shape)
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 4;
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + lineLength, legendY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(translations[currentLanguage].legendTargetShape, legendX + lineLength + 8, legendY);
            
            // Blue solid line (current shape)
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(legendX, legendY + lineSpacing);
            ctx.lineTo(legendX + lineLength, legendY + lineSpacing);
            ctx.stroke();
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(translations[currentLanguage].legendCurrentShape, legendX + lineLength + 8, legendY + lineSpacing);
        }
        
        // Render error plot
        function renderErrorPlot() {
            const plotWidth = errorPlot.width;
            const plotHeight = errorPlot.height;
            const padding = 35;
            const graphWidth = plotWidth - padding - 10;
            const graphHeight = plotHeight - 2 * padding;
            
            // Clear plot
            errorPlotCtx.fillStyle = 'white';
            errorPlotCtx.fillRect(0, 0, plotWidth, plotHeight);
            
            // Draw border
            errorPlotCtx.strokeStyle = '#ecf0f1';
            errorPlotCtx.lineWidth = 1;
            errorPlotCtx.strokeRect(padding, padding, graphWidth, graphHeight);
            
            // Draw grid lines
            errorPlotCtx.strokeStyle = '#f0f0f0';
            errorPlotCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (graphHeight / 5) * i;
                errorPlotCtx.beginPath();
                errorPlotCtx.moveTo(padding, y);
                errorPlotCtx.lineTo(padding + graphWidth, y);
                errorPlotCtx.stroke();
            }
            
            // Find max error for scaling
            const maxError = Math.max(...errorHistory, 50);
            const scale = graphHeight / maxError;
            
            // Draw error line
            if (errorHistory.length > 1) {
                errorPlotCtx.strokeStyle = '#e74c3c';
                errorPlotCtx.lineWidth = 2;
                errorPlotCtx.lineCap = 'round';
                errorPlotCtx.lineJoin = 'round';
                
                errorPlotCtx.beginPath();
                for (let i = 0; i < errorHistory.length; i++) {
                    const x = padding + (i / (errorHistory.length - 1 || 1)) * graphWidth;
                    const y = padding + graphHeight - (errorHistory[i] * scale);
                    if (i === 0) {
                        errorPlotCtx.moveTo(x, y);
                    } else {
                        errorPlotCtx.lineTo(x, y);
                    }
                }
                errorPlotCtx.stroke();
            }
            
            // Draw axis labels
            errorPlotCtx.fillStyle = '#7f8c8d';
            errorPlotCtx.font = '11px sans-serif';
            
            // Y-axis label with max value
            errorPlotCtx.textAlign = 'right';
            errorPlotCtx.fillText(`Error (px) - Max: ${maxError.toFixed(1)}`, padding - 5, 15);
            
            // Y-axis scale values
            errorPlotCtx.font = '9px sans-serif';
            errorPlotCtx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const y = padding + (graphHeight / 5) * i;
                const value = maxError - (maxError / 5) * i;
                errorPlotCtx.fillText(value.toFixed(0), padding - 5, y + 3);
            }
            
            // X-axis label
            errorPlotCtx.font = '11px sans-serif';
            errorPlotCtx.textAlign = 'center';
            errorPlotCtx.fillText('Time →', plotWidth / 2, plotHeight - 5);
        }

        // Animation loop
        function animate() {
            // Joint angles are now directly controlled by sliders
            // No need for IK solving—angles are already set
            
            // Solve cable constraints
            solveCable();
            
            // Calculate error
            rmsError = computeRmsError();
            errorHistory.push(rmsError);
            if (errorHistory.length > maxHistoryLength) {
                errorHistory.shift();
            }
            errorDisplay.textContent = rmsError.toFixed(2);
            
            // Render
            render();
            renderErrorPlot();
            
            requestAnimationFrame(animate);
        }

        // Slider controls
        const theta1Slider = document.getElementById('theta1Slider');
        const theta2Slider = document.getElementById('theta2Slider');
        const theta3Slider = document.getElementById('theta3Slider');
        const theta4Slider = document.getElementById('theta4Slider');
        
        const theta1Value = document.getElementById('theta1Value');
        const theta2Value = document.getElementById('theta2Value');
        const theta3Value = document.getElementById('theta3Value');
        const theta4Value = document.getElementById('theta4Value');
        
        theta1Slider.addEventListener('input', (e) => {
            theta1 = parseFloat(e.target.value);
            theta1Value.textContent = theta1.toFixed(2);
        });
        
        theta2Slider.addEventListener('input', (e) => {
            theta2 = parseFloat(e.target.value);
            theta2Value.textContent = theta2.toFixed(2);
        });
        
        theta3Slider.addEventListener('input', (e) => {
            theta3 = parseFloat(e.target.value);
            theta3Value.textContent = theta3.toFixed(2);
        });
        
        theta4Slider.addEventListener('input', (e) => {
            theta4 = parseFloat(e.target.value);
            theta4Value.textContent = theta4.toFixed(2);
        });

        // New target button
        newTargetBtn.addEventListener('click', generateTarget);
        newTargetBtn.addEventListener('mouseover', () => {
            newTargetBtn.style.background = '#2980b9';
        });
        newTargetBtn.addEventListener('mouseout', () => {
            newTargetBtn.style.background = '#3498db';
        });

        // Initialize and start
        initCable();
        generateTarget();
        animate();
    </script>
</body>
</html>
