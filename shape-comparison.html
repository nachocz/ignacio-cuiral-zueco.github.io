<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape Comparison Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .demo-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 20px;
            max-width: 1000px;
            width: 100%;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.8em;
        }

        .layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
        }

        .panel h3 {
            color: #2c3e50;
            font-size: 1.1em;
            margin-bottom: 12px;
            text-align: center;
        }

        canvas {
            display: block;
            background: white;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            width: 100%;
            height: auto;
        }

        #targetCanvas {
            cursor: default;
        }

        #shapesCanvas {
            cursor: crosshair;
        }

        button {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.95em;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .status {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            color: #2c3e50;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .instructions {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .plot-note {
            margin-top: 6px;
            font-size: 0.85em;
            color: #7f8c8d;
            text-align: center;
        }

        .tools {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .tool-btn {
            padding: 10px 20px;
            background: #ecf0f1;
            color: #2c3e50;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95em;
            transition: all 0.3s ease;
        }

        .tool-btn:hover {
            background: #d5dbdb;
            transform: translateY(-2px);
        }

        .tool-btn.active {
            background: #3498db;
            color: white;
            border-color: #2980b9;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        body.dark-theme {
            background: #0f1115;
            color: #e6e6e6;
        }

        body.dark-theme .demo-container,
        body.dark-theme .panel,
        body.dark-theme .instructions,
        body.dark-theme .status {
            background: #151922 !important;
            color: #e6e6e6 !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
        }

        body.dark-theme canvas {
            border-color: #2a3140;
        }

        body.dark-theme h1,
        body.dark-theme h3,
        body.dark-theme p,
        body.dark-theme li,
        body.dark-theme span,
        body.dark-theme strong {
            color: #e6e6e6 !important;
        }

        body.dark-theme button {
            background: #2c6fb3;
        }

        body.dark-theme button:hover {
            background: #3b82c4;
        }

        body.dark-theme .tool-btn {
            background: #1f2633;
            border-color: #2a3140;
            color: #e6e6e6;
        }

        body.dark-theme .tool-btn.active {
            background: #2c6fb3;
            border-color: #3b82c4;
        }
    </style>
</head>
<body class="dark-theme">
    <div class="demo-container">
        <h1>Shape Comparison Game</h1>
        
        <div class="instructions">
            <strong>How to Play</strong>
            <ul style="margin: 12px 0 12px 20px; line-height: 1.8; color: #2c3e50;">
                <li><strong>Goal:</strong> Shape the block on the right to match the red target shape on the left</li>
                <li><strong>Sculpting:</strong> The right panel shows your block as a grid of particles. Use Chisel to remove particles and Clay to add them back</li>
                <li><strong>Feedback:</strong> Your current shape appears in green on the left. The error curve shows how close you are, lower values are better</li>
            </ul>
            
            <strong>Why This Matters</strong>
            <ul style="margin: 12px 0 12px 20px; line-height: 1.8; color: #2c3e50;">
                <li>Humans naturally compare shapes and judge how closely objects match. Sculptors show this skill at its highest level, constantly adjusting their work against a target until the pieces look identical</li>
                <li>Robots need systems that help them compare shapes properly so they can know whether they are manipulating the object in the desired direction towards the target shape or away from it</li>
            </ul>
        </div>

        <div class="layout">
            <div class="panel">
                <h3>Target Shape</h3>
                <canvas id="targetCanvas" width="400" height="400"></canvas>
                <canvas id="errorCanvas" width="400" height="150" style="margin-top: 12px;"></canvas>
                <div class="plot-note">Shape mismatch residual: lower is better</div>
            </div>
            
            <div class="panel">
                <h3>Sculpting Canvas (try to match target)</h3>
                <canvas id="shapesCanvas" width="400" height="400"></canvas>
                <div class="tools" style="margin-top: 12px;">
                    <button class="tool-btn active" onclick="selectTool('chisel')" id="toolChisel">üî® Chisel (remove)</button>
                    <button class="tool-btn" onclick="selectTool('clay')" id="toolClay">üè∫ Clay (add)</button>
                </div>
                <button onclick="resetSculpt()">üîÑ Reset Block</button>
            </div>
        </div>

        <div class="status" id="statusText">
            Sculpt the shape to match the target. The residual curve updates as you sculpt.
        </div>
    </div>

    <script>
        const targetCanvas = document.getElementById('targetCanvas');
        const targetCtx = targetCanvas.getContext('2d');
        const shapesCanvas = document.getElementById('shapesCanvas');
        const shapesCtx = shapesCanvas.getContext('2d');
        const errorCanvas = document.getElementById('errorCanvas');
        const errorCtx = errorCanvas.getContext('2d');
        const statusText = document.getElementById('statusText');

        let currentTool = 'chisel';  // 'chisel' for erasing, 'clay' for adding

        function selectTool(tool) {
            currentTool = tool;
            document.getElementById('toolChisel').classList.remove('active');
            document.getElementById('toolClay').classList.remove('active');
            if (tool === 'chisel') {
                document.getElementById('toolChisel').classList.add('active');
                sculptCanvas.style.cursor = 'crosshair';
            } else {
                document.getElementById('toolClay').classList.add('active');
                sculptCanvas.style.cursor = 'cell';
            }
        }

        const NUM_POINTS = 100;
        const NUM_SHAPES = 3;  // Unused in sculpting mode
        let targetShape = [];
        let userGuess = null;
        let gameState = 'playing';
        let procrustesDistances = [];
        let targetLoaded = false;
        let isSculpting = false;
        let sculptHistory = [];
        let residualHistory = [];
        let lastResidual = null;
        let currentSculptShape = [];
        let pendingUpdate = false;

        const sculptCanvas = shapesCanvas;
        const sculptCtx = shapesCanvas.getContext('2d');
        
        // Particle grid for sculpting
        const GRID_COLS = 30;
        const GRID_ROWS = 34;
        let particleGrid = [];  // 2D array of {x, y, alive}
        const PARTICLE_RADIUS = 2;
        const ERASE_RADIUS = 20;
        const ALPHA_RADIUS = 15;  // Concavity parameter

        // Load and parse the target SVG (embedded path data)
        function loadTargetShape() {
            // Path data extracted directly from the source SVG
            const pathData = "m 760.7495,2617.5699 c 0.38246,3.9549 5.10303,31.8314 10.64711,41.2593 5.54386,9.4279 18.93547,21.0188 25.06522,21.5951 6.12975,0.5762 31.22287,-7.0403 40.34127,-13.3083 9.1184,-6.2682 16.19732,-12.3718 15.11094,-18.5306 -1.08638,-6.1587 -18.28883,-24.1643 -14.36233,-38.7585 3.92628,-14.5942 20.67115,-39.3838 19.50855,-52.6751 -1.16261,-13.2913 -14.26695,-29.8428 -33.73125,-36.6606 -19.46408,-6.8176 -28.33331,-9.0766 -39.55608,-8.7065 -11.22256,0.3701 -36.90156,16.8381 -39.55349,23.3579 -2.65193,6.5198 -14.26589,33.9295 -12.47558,42.2921 1.79052,8.3624 20.07543,32.1702 24.54446,36.5093 4.46881,4.3391 4.46118,3.6259 4.46118,3.6259 z";
            
            // Create a temporary SVG element to parse the path
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '400');
            svg.setAttribute('height', '400');
            svg.style.position = 'absolute';
            svg.style.visibility = 'hidden';
            document.body.appendChild(svg);
            
            const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathElement.setAttribute('d', pathData);
            svg.appendChild(pathElement);
            
            // Sample points along the path
            const pathLength = pathElement.getTotalLength();
            const points = [];
            
            for (let i = 0; i < 200; i++) {
                const point = pathElement.getPointAtLength((i / 200) * pathLength);
                points.push([point.x, point.y]);
            }
            
            // Remove temporary SVG
            document.body.removeChild(svg);
            
            // Normalize to canvas coordinates
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (let p of points) {
                minX = Math.min(minX, p[0]);
                maxX = Math.max(maxX, p[0]);
                minY = Math.min(minY, p[1]);
                maxY = Math.max(maxY, p[1]);
            }
            
            const width = maxX - minX;
            const height = maxY - minY;
            const scale = 225 / Math.max(width, height);
            const centerX = 200;
            const centerY = 200;
            
            const normalized = points.map(p => [
                centerX + (p[0] - (minX + maxX) / 2) * scale,
                centerY + (p[1] - (minY + maxY) / 2) * scale
            ]);
            
            targetShape = sampleUniformly(normalized, NUM_POINTS);
            targetLoaded = true;
            console.log('Target shape loaded successfully with', targetShape.length, 'points');
            resetSculpt();
        }

        // Fallback if SVG can't be loaded
        function generateFallbackTarget() {
            const points = [];
            const centerX = 200;
            const centerY = 200;
            for (let i = 0; i < 50; i++) {
                const t = i / 50;
                const angle = t * Math.PI * 2;
                const r = 60 + 20 * Math.sin(5 * angle);
                points.push([
                    centerX + r * Math.cos(angle),
                    centerY + r * 1.3 * Math.sin(angle)
                ]);
            }
            return sampleUniformly(points, NUM_POINTS);
        }

        // Generate deformed version of target
        function generateDeformedTarget(centerX, centerY, deformationType) {
            // Start with the target shape points (before sampling)
            const basePoints = [...targetShape];
            const [cx, cy] = centroid(basePoints);
            
            let deformed = basePoints.map((p, idx) => {
                const dx = p[0] - cx;
                const dy = p[1] - cy;
                const angle = Math.atan2(dy, dx);
                const dist = Math.sqrt(dx*dx + dy*dy);
                let newX, newY;
                
                switch (deformationType) {
                    case 0: // Wiggly + shear
                        const shearX = 0.15 + Math.random() * 0.2;
                        const wiggleFreq = 3 + Math.random() * 2;
                        const wiggleAmp = 3 + Math.random() * 4;
                        const wiggle = wiggleAmp * Math.sin(wiggleFreq * angle);
                        newX = dx + shearX * dy + wiggle;
                        newY = dy + wiggle * 0.5;
                        break;
                    case 1: // Wavy distortion + mild shear
                        const waveFreq = 4 + Math.random() * 3;
                        const waveAmp = 4 + Math.random() * 5;
                        const radialWave = waveAmp * Math.sin(waveFreq * angle);
                        const shearY = 0.1 + Math.random() * 0.15;
                        newX = dx + radialWave * Math.cos(angle);
                        newY = dy + radialWave * Math.sin(angle) + shearY * dx;
                        break;
                    case 2: // Sinusoidal wiggle + rotation
                        const rotAngle = (Math.random() - 0.5) * Math.PI / 4;
                        const sinWiggle = 3 + Math.random() * 4;
                        const wiggleX = sinWiggle * Math.sin(5 * angle);
                        const wiggleY = sinWiggle * Math.cos(5 * angle);
                        const rotX = dx * Math.cos(rotAngle) - dy * Math.sin(rotAngle);
                        const rotY = dx * Math.sin(rotAngle) + dy * Math.cos(rotAngle);
                        newX = rotX + wiggleX;
                        newY = rotY + wiggleY;
                        break;
                    default:
                        newX = dx;
                        newY = dy;
                }
                
                return [newX + centerX, newY + centerY];
            });
            
            // Resample uniformly after deformation to maintain consistent point distribution
            return sampleUniformly(deformed, NUM_POINTS);
        }

        function generateRandomShape(centerX, centerY) {
            const shapeType = Math.floor(Math.random() * 6);
            let points = [];
            
            switch (shapeType) {
                case 0:
                    points = generateCircle(centerX, centerY, 40 + Math.random() * 30);
                    break;
                case 1:
                    points = generateEllipse(centerX, centerY, 30 + Math.random() * 40, 30 + Math.random() * 40);
                    break;
                case 2:
                    points = generateRectangle(centerX, centerY, 50 + Math.random() * 40, 50 + Math.random() * 40);
                    break;
                case 3:
                    points = generatePolygon(centerX, centerY, 50 + Math.random() * 30, 3);
                    break;
                case 4:
                    points = generateStar(centerX, centerY, 50 + Math.random() * 30);
                    break;
                case 5:
                    points = generateBlob(centerX, centerY, 50 + Math.random() * 30);
                    break;
            }
            
            return sampleUniformly(points, NUM_POINTS);
        }

        function generateCircle(cx, cy, radius) {
            const points = [];
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                points.push([cx + radius * Math.cos(angle), cy + radius * Math.sin(angle)]);
            }
            return points;
        }

        function generateEllipse(cx, cy, rx, ry) {
            const points = [];
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);
            }
            return points;
        }

        function generateRectangle(cx, cy, width, height) {
            const points = [];
            const hw = width / 2, hh = height / 2;
            const perimeter = 2 * (width + height);
            const numPoints = 50;
            
            for (let i = 0; i < numPoints; i++) {
                const dist = (i / numPoints) * perimeter;
                let x, y;
                if (dist < width) {
                    x = cx - hw + dist;
                    y = cy - hh;
                } else if (dist < width + height) {
                    x = cx + hw;
                    y = cy - hh + (dist - width);
                } else if (dist < 2 * width + height) {
                    x = cx + hw - (dist - width - height);
                    y = cy + hh;
                } else {
                    x = cx - hw;
                    y = cy + hh - (dist - 2 * width - height);
                }
                points.push([x, y]);
            }
            return points;
        }

        function generatePolygon(cx, cy, radius, sides) {
            const points = [];
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                points.push([cx + radius * Math.cos(angle), cy + radius * Math.sin(angle)]);
            }
            return points;
        }

        function generateStar(cx, cy, radius) {
            const points = [];
            const spikes = 5;
            for (let i = 0; i < spikes * 2; i++) {
                const angle = (i / (spikes * 2)) * Math.PI * 2;
                const r = i % 2 === 0 ? radius : radius * 0.4;
                points.push([cx + r * Math.cos(angle), cy + r * Math.sin(angle)]);
            }
            return points;
        }

        function generateBlob(cx, cy, radius) {
            const points = [];
            const numPoints = 50;
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const r = radius * (0.7 + Math.random() * 0.6);
                points.push([cx + r * Math.cos(angle), cy + r * Math.sin(angle)]);
            }
            return points;
        }

        function sampleUniformly(points, numSamples) {
            if (points.length === 0) return [];
            
            const arcLengths = [0];
            for (let i = 1; i < points.length; i++) {
                const dx = points[i][0] - points[i-1][0];
                const dy = points[i][1] - points[i-1][1];
                arcLengths.push(arcLengths[i-1] + Math.sqrt(dx*dx + dy*dy));
            }
            
            const totalLength = arcLengths[arcLengths.length - 1];
            const sampledPoints = [];
            
            for (let i = 0; i < numSamples; i++) {
                const targetLength = (i / numSamples) * totalLength;
                
                let segmentIndex = 0;
                for (let j = 0; j < arcLengths.length - 1; j++) {
                    if (arcLengths[j] <= targetLength && targetLength <= arcLengths[j + 1]) {
                        segmentIndex = j;
                        break;
                    }
                }
                
                const segmentStart = arcLengths[segmentIndex];
                const segmentEnd = arcLengths[segmentIndex + 1];
                const t = (targetLength - segmentStart) / (segmentEnd - segmentStart);
                
                const p1 = points[segmentIndex];
                const p2 = points[Math.min(segmentIndex + 1, points.length - 1)];
                
                sampledPoints.push([
                    p1[0] + t * (p2[0] - p1[0]),
                    p1[1] + t * (p2[1] - p1[1])
                ]);
            }
            
            return sampledPoints;
        }

        function centroid(points) {
            const cx = points.reduce((sum, p) => sum + p[0], 0) / points.length;
            const cy = points.reduce((sum, p) => sum + p[1], 0) / points.length;
            return [cx, cy];
        }

        function centerPoints(points) {
            const [cx, cy] = centroid(points);
            return points.map(p => [p[0] - cx, p[1] - cy]);
        }

        function scale(points) {
            const sumSq = points.reduce((sum, p) => sum + p[0]*p[0] + p[1]*p[1], 0);
            const scaleFactor = Math.sqrt(sumSq);
            return points.map(p => [p[0] / scaleFactor, p[1] / scaleFactor]);
        }

        // Ray casting algorithm to test if a point is inside a polygon
        function pointInPolygon(point, polygon) {
            const [x, y] = point;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const [xi, yi] = polygon[i];
                const [xj, yj] = polygon[j];
                const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Grid-based area residual: computes symmetric difference between two shapes
        function computeAreaResidual(shape1, shape2) {
            if (shape1.length < 3 || shape2.length < 3) return 1000;
            
            // Create a grid over the canvas for fast computation
            const gridSize = 20;  // 20x20 grid
            const cellWidth = sculptCanvas.width / gridSize;
            const cellHeight = sculptCanvas.height / gridSize;
            
            let mismatchArea = 0;
            const totalCells = gridSize * gridSize;
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    // Center of grid cell
                    const cx = (i + 0.5) * cellWidth;
                    const cy = (j + 0.5) * cellHeight;
                    const point = [cx, cy];
                    
                    const inTarget = pointInPolygon(point, shape1);
                    const inSculpt = pointInPolygon(point, shape2);
                    
                    // XOR: cost if they differ
                    if (inTarget !== inSculpt) {
                        mismatchArea++;
                    }
                }
            }
            
            // Normalize to [0, 1] range, then scale for visibility
            return (mismatchArea / totalCells) * 10;
        }

        function drawShape(ctx, points, color, lineWidth = 2, fill = false) {
            if (points.length === 0) return;
            
            ctx.beginPath();
            ctx.moveTo(points[0][0], points[0][1]);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i][0], points[i][1]);
            }
            ctx.closePath();
            
            if (fill) {
                ctx.fillStyle = color + '40';
                ctx.fill();
            }
            
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }

        function drawTargetShape() {
            targetCtx.fillStyle = 'white';
            targetCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
            
            targetCtx.strokeStyle = '#f0f0f0';
            targetCtx.lineWidth = 1;
            for (let i = 0; i < targetCanvas.width; i += 50) {
                targetCtx.beginPath();
                targetCtx.moveTo(i, 0);
                targetCtx.lineTo(i, targetCanvas.height);
                targetCtx.stroke();
            }
            for (let i = 0; i < targetCanvas.height; i += 50) {
                targetCtx.beginPath();
                targetCtx.moveTo(0, i);
                targetCtx.lineTo(targetCanvas.width, i);
                targetCtx.stroke();
            }
            
            drawShape(targetCtx, targetShape, '#e74c3c', 3, true);
            
            // Overlay current sculpt shape (no alignment, just draw it)
            if (currentSculptShape.length > 0) {
                drawShape(targetCtx, currentSculptShape, '#27ae60', 3, false);
            }
            
            targetCtx.fillStyle = '#2c3e50';
            targetCtx.font = 'bold 14px Arial';
        }

        function drawErrorPlot() {
            errorCtx.fillStyle = 'white';
            errorCtx.fillRect(0, 0, errorCanvas.width, errorCanvas.height);

            errorCtx.strokeStyle = '#ecf0f1';
            errorCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = 20 + i * ((errorCanvas.height - 40) / 4);
                errorCtx.beginPath();
                errorCtx.moveTo(20, y);
                errorCtx.lineTo(errorCanvas.width - 20, y);
                errorCtx.stroke();
            }

            if (residualHistory.length < 2) return;

            const maxVal = Math.max(...residualHistory, 0.0001);
            const plotW = errorCanvas.width - 40;
            const plotH = errorCanvas.height - 40;

            errorCtx.strokeStyle = '#3498db';
            errorCtx.lineWidth = 2;
            errorCtx.beginPath();
            residualHistory.forEach((v, i) => {
                const x = 20 + (i / (residualHistory.length - 1)) * plotW;
                const y = 20 + plotH - (v / maxVal) * plotH;
                if (i === 0) {
                    errorCtx.moveTo(x, y);
                } else {
                    errorCtx.lineTo(x, y);
                }
            });
            errorCtx.stroke();

            errorCtx.fillStyle = '#7f8c8d';
            errorCtx.font = '12px Arial';
            errorCtx.fillText('Residual', 24, 16);
        }

        // Helper: Check if a grid cell is valid and alive
        function isAlive(r, c) {
            if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) return false;
            return particleGrid[r][c] && particleGrid[r][c].alive;
        }

        // Robust concave hull using grid-based boundary extraction
        function traceGridBoundary() {
            // 1. Find all cells on the boundary (alive cells with at least one dead neighbor)
            const boundaryPixels = [];
            
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (!isAlive(r, c)) continue;
                    
                    // Check if this cell touches a dead cell (is on boundary)
                    let isBoundary = false;
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            if (!isAlive(r + dr, c + dc)) {
                                isBoundary = true;
                                break;
                            }
                        }
                        if (isBoundary) break;
                    }
                    
                    if (isBoundary) {
                        boundaryPixels.push({
                            r, c,
                            x: particleGrid[r][c].x,
                            y: particleGrid[r][c].y
                        });
                    }
                }
            }

            if (boundaryPixels.length < 3) return [];

            // 2. Sort boundary pixels by angle from centroid
            const cx = boundaryPixels.reduce((s, p) => s + p.x, 0) / boundaryPixels.length;
            const cy = boundaryPixels.reduce((s, p) => s + p.y, 0) / boundaryPixels.length;
            
            boundaryPixels.sort((a, b) => {
                const angleA = Math.atan2(a.y - cy, a.x - cx);
                const angleB = Math.atan2(b.y - cy, b.x - cx);
                return angleA - angleB;
            });

            // 3. Apply smoothing to reduce sharp peaks
            // Use a wider kernel so we can run fewer iterations
            const SMOOTH_ITERS = 2;
            let smoothed = boundaryPixels.map(p => ({ x: p.x, y: p.y }));
            for (let iter = 0; iter < SMOOTH_ITERS; iter++) {
                const nextPass = [];
                for (let i = 0; i < smoothed.length; i++) {
                    const prev2 = smoothed[(i - 2 + smoothed.length) % smoothed.length];
                    const prev1 = smoothed[(i - 1 + smoothed.length) % smoothed.length];
                    const curr = smoothed[i];
                    const next1 = smoothed[(i + 1) % smoothed.length];
                    const next2 = smoothed[(i + 2) % smoothed.length];

                    const w0 = 1;
                    const w1 = 2;
                    const w2 = 3;
                    const wSum = w0 + w1 + w2 + w1 + w0;

                    nextPass.push({
                        x: (w0 * prev2.x + w1 * prev1.x + w2 * curr.x + w1 * next1.x + w0 * next2.x) / wSum,
                        y: (w0 * prev2.y + w1 * prev1.y + w2 * curr.y + w1 * next1.y + w0 * next2.y) / wSum
                    });
                }
                smoothed = nextPass;
            }

            // 4. Convert to coordinate array
            return smoothed.map(p => [p.x, p.y]);
        }

        function renderSculpt() {
            sculptCtx.fillStyle = 'white';
            sculptCtx.fillRect(0, 0, sculptCanvas.width, sculptCanvas.height);

            sculptCtx.strokeStyle = '#f0f0f0';
            sculptCtx.lineWidth = 1;
            for (let i = 0; i < sculptCanvas.width; i += 50) {
                sculptCtx.beginPath();
                sculptCtx.moveTo(i, 0);
                sculptCtx.lineTo(i, sculptCanvas.height);
                sculptCtx.stroke();
            }
            for (let i = 0; i < sculptCanvas.height; i += 50) {
                sculptCtx.beginPath();
                sculptCtx.moveTo(0, i);
                sculptCtx.lineTo(sculptCanvas.width, i);
                sculptCtx.stroke();
            }

            // Draw particles
            for (let row = 0; row < particleGrid.length; row++) {
                for (let col = 0; col < particleGrid[row].length; col++) {
                    const p = particleGrid[row][col];
                    if (p.alive) {
                        sculptCtx.fillStyle = '#1a1a1a';
                        sculptCtx.beginPath();
                        sculptCtx.arc(p.x, p.y, PARTICLE_RADIUS, 0, Math.PI * 2);
                        sculptCtx.fill();
                    }
                }
            }

            // Draw contour
            if (currentSculptShape.length > 0) {
                drawShape(sculptCtx, currentSculptShape, '#d0d0d0', 2, false);
            }
        }

        function getSculptShape() {
            // Trace the grid structure to get the boundary contour
            const contour = traceGridBoundary();
            
            // If contour is too small (e.g. completely erased), return empty
            if (contour.length < 3) return [];

            // The rest of the pipeline expects a specific number of sampled points
            // sampleUniformly handles the smoothing and point distribution
            return sampleUniformly(contour, NUM_POINTS);
        }

        function removeDisconnectedParticles() {
            // Find all connected components using flood fill
            const visited = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                visited[r] = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    visited[r][c] = false;
                }
            }

            // Find all connected components
            const components = [];
            function floodFill(startR, startC, component) {
                const stack = [[startR, startC]];
                while (stack.length > 0) {
                    const [r, c] = stack.pop();
                    if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) continue;
                    if (visited[r][c] || !isAlive(r, c)) continue;
                    
                    visited[r][c] = true;
                    component.push([r, c]);
                    
                    // Check 8 neighbors
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            stack.push([r + dr, c + dc]);
                        }
                    }
                }
            }

            // Find all components
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (!visited[r][c] && isAlive(r, c)) {
                        const component = [];
                        floodFill(r, c, component);
                        components.push(component);
                    }
                }
            }

            // Find the largest component
            if (components.length === 0) return;
            let largestComponent = components[0];
            for (let comp of components) {
                if (comp.length > largestComponent.length) {
                    largestComponent = comp;
                }
            }

            // Mark all particles not in largest component as dead
            const largestSet = new Set(largestComponent.map(p => `${p[0]},${p[1]}`));
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (isAlive(r, c) && !largestSet.has(`${r},${c}`)) {
                        particleGrid[r][c].alive = false;
                    }
                }
            }
        }

        function updateResidualAndRender() {
            if (!targetLoaded) return;

            removeDisconnectedParticles();

            currentSculptShape = getSculptShape();
            if (currentSculptShape.length > 0) {
                lastResidual = computeAreaResidual(targetShape, currentSculptShape);
                residualHistory.push(lastResidual);
                if (residualHistory.length > 200) residualHistory.shift();
                statusText.textContent = `Current shape mismatch (lower is better): ${lastResidual.toFixed(4)}`;
                statusText.style.background = '#ecf0f1';
            }

            renderSculpt();
            drawTargetShape();
            drawErrorPlot();
        }

        function scheduleUpdate() {
            if (pendingUpdate) return;
            pendingUpdate = true;
            requestAnimationFrame(() => {
                pendingUpdate = false;
                updateResidualAndRender();
            });
        }

        function resetSculpt() {
            if (!targetLoaded) return;

            // Initialize particle grid
            particleGrid = [];
            const startX = 50;
            const startY = 40;
            const endX = sculptCanvas.width - 50;
            const endY = sculptCanvas.height - 40;
            const stepX = (endX - startX) / (GRID_COLS - 1);
            const stepY = (endY - startY) / (GRID_ROWS - 1);

            for (let row = 0; row < GRID_ROWS; row++) {
                particleGrid[row] = [];
                for (let col = 0; col < GRID_COLS; col++) {
                    particleGrid[row][col] = {
                        x: startX + col * stepX,
                        y: startY + row * stepY,
                        alive: true
                    };
                }
            }

            residualHistory = [];
            currentSculptShape = [];
            statusText.textContent = 'Sculpt the shape to match the target.';
            statusText.style.background = '#ecf0f1';

            updateResidualAndRender();
        }

        function eraseAt(x, y) {
            let changed = false;
            for (let row = 0; row < particleGrid.length; row++) {
                for (let col = 0; col < particleGrid[row].length; col++) {
                    const p = particleGrid[row][col];
                    const dx = p.x - x;
                    const dy = p.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < ERASE_RADIUS) {
                        if (currentTool === 'chisel') {
                            // Remove material (chisel)
                            if (p.alive) {
                                p.alive = false;
                                changed = true;
                            }
                        } else {
                            // Add material (clay)
                            if (!p.alive) {
                                p.alive = true;
                                changed = true;
                            }
                        }
                    }
                }
            }
            if (changed) scheduleUpdate();
        }

        function getCanvasPos(e) {
            const rect = sculptCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (sculptCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (sculptCanvas.height / rect.height);
            return { x, y };
        }

        sculptCanvas.addEventListener('mousedown', (e) => {
            isSculpting = true;
            const { x, y } = getCanvasPos(e);
            eraseAt(x, y);
        });

        sculptCanvas.addEventListener('mousemove', (e) => {
            if (!isSculpting) return;
            const { x, y } = getCanvasPos(e);
            eraseAt(x, y);
        });

        sculptCanvas.addEventListener('mouseup', () => {
            isSculpting = false;
        });

        sculptCanvas.addEventListener('mouseleave', () => {
            isSculpting = false;
        });

        // Initialize by loading the target shape
        loadTargetShape();
    </script>
</body>
</html>
